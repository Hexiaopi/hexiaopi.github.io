import{_ as e}from"./MySQL-Read-Simple-1q8N7gNF.js";import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as o,a as i,f as n}from"./app-CZ3y1Fod.js";const l="/assets/MySQL-Write-Process-xpoJGYQm.png",r={},s=n('<h2 id="执行流程" tabindex="-1"><a class="header-anchor" href="#执行流程"><span>执行流程</span></a></h2><blockquote><p>查询语句执行的流程，更新语句也会执行类似的过程，稍有差别的地方是更新语句会将更新表的所有缓存清理，这就是为什么不建议使用查询缓存。</p></blockquote><figure><img src="'+e+`" alt="交互流程" tabindex="0" loading="lazy"><figcaption>交互流程</figcaption></figure><h3 id="日志模块" tabindex="-1"><a class="header-anchor" href="#日志模块"><span>日志模块</span></a></h3><blockquote><p>更重要的是MySQL的日志模块，这是数据库提供高可用以及事务的重要模块</p></blockquote><p>我们以InnoDB引擎和一条更新语句为例</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">update</span> T <span class="token keyword">set</span> c<span class="token operator">=</span>c<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+l+'" alt="写流程" tabindex="0" loading="lazy"><figcaption>写流程</figcaption></figure><ul><li>蓝色框是MySQL服务层处理过程</li><li>绿色框是InnoDB引擎层处理过程</li></ul><p>其中：</p><ul><li>undolog用于InnoDB记录事务回滚日志</li><li>redolog用于InnoDB记录事务前滚日志，保障事务<code>crash-safe</code></li><li>binlog是MySQL服务层归档日志</li></ul><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎记录undolog</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>redolog的写入拆成了两个步骤：prepare和commit，这就是<strong>两阶段提交</strong></p>',13);function p(c,d){return a(),o("div",null,[i(" more "),s])}const h=t(r,[["render",p],["__file","write-process.html.vue"]]),y=JSON.parse('{"path":"/database/mysql/write-process.html","title":"写入过程","lang":"zh-CN","frontmatter":{"title":"写入过程","date":"2022-10-22T00:00:00.000Z","tag":["MySQL","数据库"],"category":["数据库"],"head":[["meta",{"property":"og:url","content":"http://blog.cjhe.top/database/mysql/write-process.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"写入过程"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-15T09:57:53.000Z"}],["meta",{"property":"article:author","content":"Hexiaopi"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2022-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-15T09:57:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"写入过程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-15T09:57:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hexiaopi\\",\\"url\\":\\"https://github.com/Hexiaopi\\"}]}"]]},"headers":[{"level":2,"title":"执行流程","slug":"执行流程","link":"#执行流程","children":[{"level":3,"title":"日志模块","slug":"日志模块","link":"#日志模块","children":[]}]}],"git":{"createdTime":1653214706000,"updatedTime":1713175073000,"contributors":[{"name":"hexiaopi","email":"hechangjie0619@icloud.com","commits":2},{"name":"HeXiaoPi","email":"hechangjie0619@icloud.com","commits":1}]},"readingTime":{"minutes":1.65,"words":496},"filePathRelative":"database/mysql/write-process.md","localizedDate":"2022年10月22日","excerpt":""}');export{h as comp,y as data};
