import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c,f as d,a as e,b as o,d as n,e as s}from"./app-5a4e179b.js";const u="/assets/goroutine-351af3e1.png",h={},g=e("p",null,"Go语言原生支持并发能力，而goroutine是Go语言原生支持并发的具体实现，本篇将为你揭开goroutine的面纱。",-1),p=e("figure",null,[e("img",{src:"http://cdn.cjhe.top/blog/goroutine.png",alt:"goroutine",tabindex:"0",loading:"lazy"}),e("figcaption",null,"goroutine")],-1),G=s('<h2 id="goroutine" tabindex="-1"><a class="header-anchor" href="#goroutine" aria-hidden="true">#</a> goroutine</h2><p>goroutine是由Go运行时管理的用户层轻量级线程，相比较操作系统线程，goroutine的资源占用和使用代价都要小的多，一个goroutine初始只需要2KB的内存，而线程需要MB级别的空间，这样在有限的内存空间里，可以创建的goroutine的数量相比较线程数量多的多。其次由于线程切换需要拷贝大量的上下文，这就导致线程切换耗时较高。</p><h2 id="gpm模型" tabindex="-1"><a class="header-anchor" href="#gpm模型" aria-hidden="true">#</a> GPM模型</h2><figure><img src="'+u+'" alt="goroutine" tabindex="0" loading="lazy"><figcaption>goroutine</figcaption></figure><p>GPM模型中：</p><ul><li>G代表<code>goroutine</code>，存储了<code>goroutine</code>的执行栈信息、<code>goroutine</code>状态及<code>goroutine</code>的任务函数等</li><li>P代表<code>processor</code>，逻辑处理器，所有的P都在程序启动时创建，P的数量决定了系统内最大可并行的G的数量，最多有<code>GOMAXPROCS</code>(可配置)个</li><li>M代表<code>thread</code>即用户态线程，M在绑定有效的P后，进入到一个调度循环：从各种队列、P的本地队列获取G，切换到G的执行栈上并执行G的函数，调用<code>goexit</code>做清理工作并回到M，如此反复。</li></ul><p>此外还有：</p><ul><li>全局队列(Global Queue)：存放等待运行的G</li><li>P的本地队列(Local Queue)：存放的也是等待运行的G，数量不超过256个。 <ul><li>当G新建goroutine G&#39;时，G&#39;优先加入到P的本地队列(局部性，G和G&#39;相关)</li><li>如果本地队列满了，则会把本地队列中的一半G移动到全局队列</li></ul></li></ul><h2 id="调度策略" tabindex="-1"><a class="header-anchor" href="#调度策略" aria-hidden="true">#</a> 调度策略</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>其思想：复用线程M，避免频繁的创建、销毁</p></div><h3 id="work-stealing机制" tabindex="-1"><a class="header-anchor" href="#work-stealing机制" aria-hidden="true">#</a> work stealing机制</h3><p>当本地队列无可运行的G时，会尝试从其他P队列中偷取G，而不是销毁M</p><h3 id="hand-off机制" tabindex="-1"><a class="header-anchor" href="#hand-off机制" aria-hidden="true">#</a> hand off机制</h3><p>当M因为G进行系统调用阻塞时，M会释放绑定的P，此时的M和G都进入阻塞状态</p><ul><li>如果此时有空闲的M，P会与其绑定并执行剩余的G，</li><li>如果没有空闲的M，则会创建新的M</li></ul><p>当系统调用返回后，阻塞在该系统调用的G会尝试获取一个可用的P</p><ul><li>如果有可用的P，之前运行该G的M将绑定P继续运行G</li><li>如果没有可用的P，那么G于M之间的关联将解除，同时G会标记为runable，放入全局队列等待调度</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>网络I/O不会阻塞M，仅阻塞G</li><li>文件I/O会阻塞M，这就是为什么大量文件I/O操作会导致大量线程被创建的原因。</li></ul></div><h3 id="抢占调度" tabindex="-1"><a class="header-anchor" href="#抢占调度" aria-hidden="true">#</a> 抢占调度</h3>',19),_=e("strong",null,"时间片",-1),f=e("strong",null,"时间片",-1),m=e("strong",null,"M是如何让G停下来并调度下一个可运行的G呢",-1),M=e("br",null,null,-1),b=e("ul",null,[e("li",null,"Go1.2版本在每个函数或方法的入口增加一段额外的代码，让运行时有机会检查是否需要执行抢占调度；（对没有函数调用的G无效）"),e("li",null,[o("Go程序运行时会启动一个名为"),e("code",null,"sysmon"),o("的M（称为监控线程），该M无须绑定P即可运行（以g0这个G的形式），该M对于长时间运行（超过10ms）的G发出抢占式调度。")])],-1),P=e("h2",{id:"参考文献",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考文献","aria-hidden":"true"},"#"),o(" 参考文献")],-1),x={href:"https://mp.weixin.qq.com/s/rfjysi-LB-uFiGiZjh-XNw",target:"_blank",rel:"noopener noreferrer"},k={href:"https://book.douban.com/subject/35720729/",target:"_blank",rel:"noopener noreferrer"};function B(v,w){const a=t("Badge"),i=t("ExternalLinkIcon");return r(),c("div",null,[g,p,d(" more "),G,e("p",null,[o("与操作系统按"),_,o("调度线程不同，Go中没有"),f,o("的概念。如果某个G没有进行系统调用，没有进行I/O操作、没有阻塞在一个channel操作上，那么"),m,o("？"),n(a,{text:"注意",type:"warning"}),M,o(" 答案是：G被抢占调度的")]),b,P,e("ul",null,[e("li",null,[e("a",x,[o("文章-Golang调度器GMP原理与调度全分析"),n(i)])]),e("li",null,[e("a",k,[o("书籍-Go语言精进之路"),n(i)])])])])}const O=l(h,[["render",B],["__file","goroutine.html.vue"]]);export{O as default};
