import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,c as l,a as p,e as a,f as n,d as e,b as s,o as c}from"./app-BxIvKJnO.js";const u="/assets/mutex-BwL0u7Um.png",r="/assets/mutex-simple-dNMGJbCf.png",d="/assets/mutex-complex-BfVmDsNk.png",m="/assets/rwmutex-logic-CgDtJGMM.png",k={},v=s(`<p>Go语言sync包提供了两种锁：</p><ul><li>互斥锁 Mutex: <ul><li>加锁时，其他加锁协程均阻塞</li></ul></li><li>读写锁 RWMutex: <ul><li>加读锁时，加写锁协程阻塞，加读锁协程不阻塞</li><li>加写锁时，其他加读写协程均阻塞</li></ul></li></ul><h2 id="互斥锁-mutex" tabindex="-1"><a class="header-anchor" href="#互斥锁-mutex"><span>互斥锁 Mutex</span></a></h2><h3 id="mutex数据结构" tabindex="-1"><a class="header-anchor" href="#mutex数据结构"><span>Mutex数据结构</span></a></h3><p>参见<code>$GOROOT/src/sync/mutex.go</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> Mutex <span class="token keyword">struct</span><span class="token punctuation">{</span>
  state <span class="token builtin">int32</span>
  sema  <span class="token builtin">uint32</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中：</p><ul><li>state: 表示互斥锁的状态，比如是否被锁定等；</li><li>sema: 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程；</li></ul><p>Mutex.state虽然是<code>int32</code>数据类型，内部实现时把该变量分成四份，用于记录Mutex的四种状态</p><figure><img src="`+u+'" alt="mutex" tabindex="0" loading="lazy"><figcaption>mutex</figcaption></figure><ul><li>Locked: 表示该Mutex是否已被锁定，0表示没有锁定，1表示已锁定</li><li>Woken: 表示是否协程已被唤醒，0表示没有协程唤醒，1表示已有协程唤醒</li><li>Starving: 表示该Mutex是否处于饥饿状态，0表示没有饥饿，1表示饥饿状态（说明已有协程阻塞时间超过1ms）</li><li>Waiter: 表示阻塞等待协程的个数，协程解锁时根据此值来判断是否需要释放信号量</li></ul><h3 id="mutex的方法" tabindex="-1"><a class="header-anchor" href="#mutex的方法"><span>Mutex的方法</span></a></h3><p>Mutex对外提供两个方法：</p><ul><li>Lock(): 加锁方法</li><li>Unlock(): 解锁方法</li></ul><h4 id="单个协程的加锁释放过程" tabindex="-1"><a class="header-anchor" href="#单个协程的加锁释放过程"><span>单个协程的加锁释放过程</span></a></h4><p>Mutex内部<code>state</code>表示如下：</p><figure><img src="'+r+'" alt="mutex-simple" tabindex="0" loading="lazy"><figcaption>mutex-simple</figcaption></figure><h4 id="两个协程的加锁释放过程" tabindex="-1"><a class="header-anchor" href="#两个协程的加锁释放过程"><span>两个协程的加锁释放过程</span></a></h4><p>Mutex内部<code>state</code>表示如下：</p><figure><img src="'+d+'" alt="mutex-comple" tabindex="0" loading="lazy"><figcaption>mutex-comple</figcaption></figure><p>上面介绍Mutex加锁和解锁只使用内部<code>state</code>标记：<code>Waiter</code>和<code>Locked</code>两个，另外两个标记就不得不提自旋过程了。</p><h3 id="自旋过程" tabindex="-1"><a class="header-anchor" href="#自旋过程"><span>自旋过程</span></a></h3><blockquote><p>自旋过程是：加锁时，如果当前<code>Locked</code>为1，则说明当前该锁由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续地探测<code>Locked</code>是否变为0，这个过程就是自旋过程。</p></blockquote><details class="hint-container details"><summary>自旋的条件</summary><ul><li>自旋次数要足够少，通常为4；</li><li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁；</li><li>协程调度GMP中的P的数量要大于1；</li><li>协程调度运行队列必须为空，否则会延迟协程调度；</li></ul></details><div class="hint-container tip"><p class="hint-container-title">提示</p><p>自旋的好处：当加锁失败时不必立即转入阻塞，有一定机会获得锁，避免协程的切换。</p></div><p>自旋的时间很短，如果自旋过程中发现锁已被释放，那么协程可以立即获取锁，此时即便有其他协程被唤醒也无法获取锁，只能再次阻塞。</p>',26),g=a("strong",null,"饥饿",-1),x=a("code",null,"Starving",-1),h=s(`<p>如果此时有两个协程，一个在加锁，另一个在解锁，在加锁的过程中可能处于自旋，此时会把<code>Woken</code>标记为1，用于告知解锁协程，不必释放信号量，它很快会拿到锁。</p><h3 id="mutex注意事项" tabindex="-1"><a class="header-anchor" href="#mutex注意事项"><span>Mutex注意事项</span></a></h3><div class="hint-container caution"><p class="hint-container-title">警告</p><p>Mutex等sync中定义的结构类型首次使用后不应对其进行复制操作</p></div><p>我们看一个示例：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> foo <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	n <span class="token builtin">int</span>
	sync<span class="token punctuation">.</span>Mutex
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	f <span class="token operator">:=</span> foo<span class="token punctuation">{</span>n<span class="token punctuation">:</span> <span class="token number">17</span><span class="token punctuation">}</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>f foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g2: try to lock foo...&quot;</span><span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g2: lock foo ok&quot;</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g2: unlock foo ok&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>

	f<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g1: lock foo ok&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// 在mutex首次使用后复制其值</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>f foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g3: try to lock foo...&quot;</span><span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g3: lock foo ok&quot;</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g3: unlock foo ok&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	f<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;g1: unlock foo ok&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>查看执行结果</summary><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>2023/03/12 19:23:45 g1: lock foo ok
2023/03/12 19:23:45 g2: try to lock foo...
2023/03/12 19:23:45 g3: try to lock foo...
2023/03/12 19:23:45 g2: lock foo ok
2023/03/12 19:23:48 g2: unlock foo ok
2023/03/12 19:23:48 g2: try to lock foo...
2023/03/12 19:23:48 g2: lock foo ok
2023/03/12 19:23:51 g2: unlock foo ok
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到g3在加锁操作之后阻塞，而g2按照预期正常运行</p><p>g2和g3的区别在于：</p><ul><li>g2是在互斥锁首次使用之前创建</li><li>g3是在互斥锁执行完加锁操作之后创建，并且在创建g3的时候复制了foo实例</li></ul></details>`,6),b=s(`<h2 id="读写锁-rwmutex" tabindex="-1"><a class="header-anchor" href="#读写锁-rwmutex"><span>读写锁 RWMutex</span></a></h2><h3 id="rwmutex数据结构" tabindex="-1"><a class="header-anchor" href="#rwmutex数据结构"><span>RWMutex数据结构</span></a></h3><p>参见<code>$GOROOT/src/sync/mutex.go</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> RWMutex <span class="token keyword">struct</span><span class="token punctuation">{</span>
  w           Mutex
  writerSem   <span class="token builtin">uint32</span>
  readerSem   <span class="token builtin">uint32</span>
  readerCount <span class="token builtin">int32</span>
  readerWait  <span class="token builtin">int32</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中：</p><ul><li>w: 用于控制多个写锁，获得写锁首先要获取该锁</li><li>writerSem: 写阻塞的协程等待的信号量，最后一个读协程释放锁时会释放信号量</li><li>readerSem: 读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</li><li>readerCount: 记录读协程的个数</li><li>readerWait: 记录写阻塞时的读协程个数</li></ul><h3 id="rwmutex的方法" tabindex="-1"><a class="header-anchor" href="#rwmutex的方法"><span>RWMutex的方法</span></a></h3><ul><li>RLock(): 加读锁 <ul><li>增加读操作计数，即readerCount++</li><li>如果已经有持有写锁协程，则阻塞自己</li></ul></li><li>RUnlock(): 释放读锁 <ul><li>减少读操作计数，即readerCount--</li><li>如果有阻塞的写锁协程，则唤醒它</li></ul></li><li>Lock(): 加写锁 <ul><li>获取互斥锁</li><li>如果持有读锁协程，则阻塞自己，等待所有的读操作结束</li></ul></li><li>Unlock(): 释放写锁 <ul><li>释放互斥锁</li><li>如果其他阻塞的读锁协程，则唤醒它</li></ul></li></ul><figure><img src="`+m+'" alt="rwmutex" tabindex="0" loading="lazy"><figcaption>rwmutex</figcaption></figure><h3 id="rwmutex的细节分析" tabindex="-1"><a class="header-anchor" href="#rwmutex的细节分析"><span>RWMutex的细节分析</span></a></h3><h4 id="写操作是如何阻止写操作的" tabindex="-1"><a class="header-anchor" href="#写操作是如何阻止写操作的"><span>写操作是如何阻止写操作的？</span></a></h4><p>读写锁RWMutex包含一个互斥锁w，获取写锁必须先获取该互斥锁，如果互斥锁已被其他协程持有，则只能阻塞等待。</p><h4 id="写操作是如何阻止读操作的" tabindex="-1"><a class="header-anchor" href="#写操作是如何阻止读操作的"><span>写操作是如何阻止读操作的？</span></a></h4><p>读写锁RWMutex包含当前读协程数量readerCount，每次获取读锁则加1，每次释放读锁则减1，因此取值为[0,N],N最大为2e30。 当获取写锁时，会将readerCount减去2e30，变成了负值。获取读锁协程检测到readerCount为负值，便知道正在加写锁，只好阻塞自己。 真实的readerCount不会丢失，只需要加2e30即可。</p><h4 id="读操作是如何阻止写操作的" tabindex="-1"><a class="header-anchor" href="#读操作是如何阻止写操作的"><span>读操作是如何阻止写操作的？</span></a></h4><p>读锁会先将RWMutex.readerCount加1，写锁协程检测到readerCount不为0，则会阻塞自己。</p><h4 id="写锁为什么不会被饿死" tabindex="-1"><a class="header-anchor" href="#写锁为什么不会被饿死"><span>写锁为什么不会被<strong>饿死</strong>？</span></a></h4><p>获取写锁期间，可能还有其他协程获取读锁，如果写锁一直等待所有的读操作结束，则很可能被<strong>饿死</strong>，RWMutex通过readerWait解决这个问题，当获取写锁时，会把readerCount复制到readerWait，用于标记排在写操作前面的读操作个数，读操作结束会递减readerCount的值，同时也会递减readerWait的值，当readerWait值为0时唤醒写操作。写操作结束后才会唤醒其他的读操作。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://book.douban.com/subject/35144587/" target="_blank" rel="noopener noreferrer">Go专家编程</a></p>',20);function f(y,w){const t=o("Badge");return c(),l("div",null,[p(" more "),v,a("p",null,[n("如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，之前阻塞的协程一直获取不到锁（超过1ms）将进入"),g,n("状态"),e(t,{text:"注意",type:"warning"}),n("。为了避免这个问题，Go1.8版本Mutex增加新的状态"),x,n("，这个状态下不会自旋，一旦协程释放锁，就会唤醒一个等待加锁协程。")]),h,a("p",null,[n("sync包中类型的实例在被复制得到的副本后将脱离原实例的控制范围，因此推荐传指针的方式"),e(t,{text:"注意",type:"warning"}),n("，保证使用的锁是同一实例。")]),b])}const q=i(k,[["render",f],["__file","mutex.html.vue"]]),W=JSON.parse('{"path":"/language/go/advance/mutex.html","title":"深入了解mutex原理","lang":"zh-CN","frontmatter":{"title":"深入了解mutex原理","date":"2023-03-11T00:00:00.000Z","tag":["Go","进阶"],"category":["编程语言"],"head":[["meta",{"property":"og:url","content":"http://blog.cjhe.top/language/go/advance/mutex.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"深入了解mutex原理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-10T12:23:49.000Z"}],["meta",{"property":"article:author","content":"Hexiaopi"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"进阶"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-10T12:23:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入了解mutex原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-10T12:23:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Hexiaopi\\",\\"url\\":\\"https://github.com/Hexiaopi\\"}]}"]]},"headers":[{"level":2,"title":"互斥锁 Mutex","slug":"互斥锁-mutex","link":"#互斥锁-mutex","children":[{"level":3,"title":"Mutex数据结构","slug":"mutex数据结构","link":"#mutex数据结构","children":[]},{"level":3,"title":"Mutex的方法","slug":"mutex的方法","link":"#mutex的方法","children":[]},{"level":3,"title":"自旋过程","slug":"自旋过程","link":"#自旋过程","children":[]},{"level":3,"title":"Mutex注意事项","slug":"mutex注意事项","link":"#mutex注意事项","children":[]}]},{"level":2,"title":"读写锁 RWMutex","slug":"读写锁-rwmutex","link":"#读写锁-rwmutex","children":[{"level":3,"title":"RWMutex数据结构","slug":"rwmutex数据结构","link":"#rwmutex数据结构","children":[]},{"level":3,"title":"RWMutex的方法","slug":"rwmutex的方法","link":"#rwmutex的方法","children":[]},{"level":3,"title":"RWMutex的细节分析","slug":"rwmutex的细节分析","link":"#rwmutex的细节分析","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1690708801000,"updatedTime":1728563029000,"contributors":[{"name":"HeXiaoPi","email":"hechangjie0619@icloud.com","commits":3}]},"readingTime":{"minutes":6.04,"words":1812},"filePathRelative":"language/go/advance/mutex.md","localizedDate":"2023年3月11日","excerpt":""}');export{q as comp,W as data};
