import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as s,a as t,b as e,d,e as r}from"./app-96934de4.js";const a="/assets/MQTT通信模式-71ed268b.png",c="/assets/MQTT-QoS-285649d6.png",g="/assets/MQTT交互时序-8c00f555.png",h={},u=t("blockquote",null,[t("p",null,"MQTT(Mesage Queuing Telemetry Transport，消息队列遥测传输协议)，是一种基于发布/订阅模式的轻量级通讯协议，该协议构建于TCP/IP协议上。")],-1),x=t("h2",{id:"发展历史",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#发展历史","aria-hidden":"true"},"#"),e(" 发展历史")],-1),y=t("li",null,"1999年由IBM发明，起初用于原油管道数据采集监控系统，解决卫星与原油管道检测数据的传输问题。",-1),p=t("li",null,"2010 发布MQTT 3.1。",-1),b=t("strong",null,"OASIS",-1),m={href:"https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html",target:"_blank",rel:"noopener noreferrer"},T=t("code",null,"V3.1.1",-1),S={href:"https://docs.oasis-open.org/mqtt/mqtt/v5.0/cs02/mqtt-v5.0-cs02.html",target:"_blank",rel:"noopener noreferrer"},f=t("code",null,"V5.0",-1),Q=r('<h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><ul><li>支持QoS（设备网络环境复杂）</li><li>轻量且省带宽（MQTT报文紧凑，可在严重受限的硬件设备和低带宽、高延迟的网络上实现稳定传输）</li><li>发布订阅模式，将发布者与订阅者解耦</li><li>持续会话感知能力（时刻知道设备是否在线）</li></ul><h2 id="通信模式" tabindex="-1"><a class="header-anchor" href="#通信模式" aria-hidden="true">#</a> 通信模式</h2><blockquote><p>发布/订阅模式(Publish/Subscribe)将发送消息的发布者(Publisher)与接收消息的订阅者(Subscriber)分离，之间的连接关系由代理者(Broker)进行处理。两者不直接进行通信，甚至彼此之前都不知道对方的存在。</p></blockquote><figure><img src="'+a+`" alt="MQTT通信模式" tabindex="0" loading="lazy"><figcaption>MQTT通信模式</figcaption></figure><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><blockquote><p>发布/订阅模式的重要特性就是将消息的发布者与订阅者解耦，这种解耦体现在以下三个方面：</p><ul><li>空间解耦：发布者和订阅者不需要相互了解（例如无须交换IP地址与端口）；</li><li>时间解耦：发布者与订阅者的操作不需要同时运行（可下线）；</li><li>同步解耦：在发布或者订阅消息的过程当中，发布者和订阅者可以异步进行工作（C/S模式需要客户端或服务端等待）；</li></ul></blockquote><p>Broker通过某种<strong>过滤规则</strong>将Publisher的消息发送给Subscriber，该<strong>过滤规则</strong>就是<strong>Topic</strong></p><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><h3 id="主题-topic" tabindex="-1"><a class="header-anchor" href="#主题-topic" aria-hidden="true">#</a> 主题 Topic</h3><blockquote><p>MQTT 协议的<strong>主题</strong>（Topic）是指<strong>代理者</strong>用于为<strong>客户端</strong>过滤与路由消息的 <strong>UTF-8 编码字符串</strong></p><p>一个<strong>主题</strong>是由一个或者多个<strong>主题级别</strong>（Topic Level）构成，每个主题级别由正斜线 <code>/</code> 进行分隔。</p><p>例如：&lt;父级Topic名称&gt;/&lt;二级Topic名称&gt;/&lt;三级Topic名称&gt;</p><p>每个<strong>主题</strong>必须至少包含 1 个字符（一个单独的斜杆 <code>/</code> 也是一个有效的主题），并且主题字符串允许存在<strong>空格</strong>。</p><p>主题<strong>区分大小写</strong>，<code>home/temperature</code> 与 <code>Home/Temperature</code> 是 2 个不同的<strong>主题</strong>。</p><p>主题不需要提前创建，发布者发送消息到某个主题或订阅者订阅某个主题时，Broker就会自动创建</p></blockquote><h4 id="通配符" tabindex="-1"><a class="header-anchor" href="#通配符" aria-hidden="true">#</a> 通配符</h4><ul><li><p>单级通配符：<code>+</code></p><blockquote><p>只能匹配一个主题级别</p></blockquote></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  例如：订阅myhome/groundfloor/+/temperature
  myhome/groundfloor/livingroom/temperature		//匹配
  myhome/groundfloor/kitchen/temperature			//匹配
  myhome/groundfloor/kitchen/brightness			//不匹配
  myhome/firstfloor/kitchen/temperature			//不匹配
  myhome/groundfloor/kitchen/fridge/temperature	//不匹配
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>多级通配符：<code>#</code></p><blockquote><p>可以匹配多个主题级别</p></blockquote></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  例如：订阅myhome/groundfloor/#
  myhome/groundfloor/livingroom/temperature		//匹配
  myhome/groundfloor/kitchen/temperature			//匹配
  myhome/groundfloor/kitchen/brightness			//匹配
  myhome/firstfloor/kitchen/temperature			//不匹配
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>系统保留主题：<code>$</code></p><blockquote><p>MQTT系统内部保留，用于代理者内部统计信息</p></blockquote></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  $SYS/broker/clients/disconnected
  $SYS/broker/clients/connected
  $SYS/broker/messages/sent
  $SYS/broker/clients/total
  $SYS/broker/uptime
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="用例" tabindex="-1"><a class="header-anchor" href="#用例" aria-hidden="true">#</a> 用例</h4><p>比如我们用传感器监视家里的卧室、客厅以及厨房的温度、湿度和空气质量，可以设计一下几个主题：</p><ul><li><code>myhome/bedroom/temperature</code></li><li><code>myhome/bedroom/humidity</code></li><li><code>myhome/bedroom/airquality</code></li><li><code>myhome/livingroom/temperature</code></li><li><code>myhome/livingroom/humidity</code></li><li><code>myhome/livingroom/airquality</code></li><li><code>myhome/kitchen/temperature</code></li><li><code>myhome/kitchen/humidity</code></li><li><code>myhome/kitchen/airquality</code></li></ul><p>当我们想获取卧室的所有数据时，可以订阅 <code>myhome/bedroom/+</code> 主题，当我们想获取三个房间的温度数据的时候，可以订阅 <code>myhome/+/temperature</code> 主题，当我们想获取所有的数据的时候，可以订阅 <code>myhome/#</code> 或者 <code>#</code>。</p><h4 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a> 最佳实践</h4><ul><li>切勿在主题开头使用正斜杠 <code>/</code>，避免引入一个<strong>零字符</strong>作为不必要的主题级别；</li><li>永远不要在主题中使用空格（包括 UTF-8 当中不同类型的空白），从而避免为阅读和调试带来不必要的困扰；</li><li>尽量保持主题简短，对于资源有限的物联网设备，每个字节占用的存储空间都非常重要；</li><li>仅使用 ASCII 字符，避免使用一些不可打印的字符；</li><li>将唯一标识符或者<strong>客户端</strong> ID 嵌入主题，从而方便的识别消息的发送者；</li><li>不要轻易直接订阅 <code>#</code>，即不要直接使用<strong>多级通配符</strong>订阅<strong>代理者</strong>上发布的全部消息，避免给<strong>订阅者</strong>带来过大的数据吞吐量；</li><li>优化主题层次结构，保持主题命名的长期扩展性；</li></ul><h3 id="服务质量-qos" tabindex="-1"><a class="header-anchor" href="#服务质量-qos" aria-hidden="true">#</a> 服务质量 QoS</h3><ul><li>QoS-0(至多一次)：接收方不会确认收到消息，发送发也不会存储和重新传输消息，消息发布完全依赖底层TCP/IP网络，消息可能会丢失。</li><li>QoS-1(至少一次)：发送方会存储消息直至接收方获得确认消息的PUBACK数据包为止，确保消息到达，但可能会出现重复；</li><li>QoS-2(只有一次)：确保消息到达且没有重复。</li></ul><figure><img src="`+c+'" alt="MQTT-QoS" tabindex="0" loading="lazy"><figcaption>MQTT-QoS</figcaption></figure>',27),k={href:"http://www.steves-internet-guide.com/mqtt-publish-subscribe/",target:"_blank",rel:"noopener noreferrer"},C=r('<ul><li>当客户端 A 的发布 QoS 大于客户端 B 的订阅 QoS 时，服务端向客户端 B 转发消息时使用的 QoS 为客户端 B 的订阅 QoS。</li><li>当客户端 A 的发布 QoS 小于客户端 B 的订阅 QoS 时，服务端向客户端 B 转发消息时使用的 QoS 为客户端 A 的发布 QoS</li></ul><h3 id="消息类型" tabindex="-1"><a class="header-anchor" href="#消息类型" aria-hidden="true">#</a> 消息类型</h3><ul><li>CONNECT/CONNACK 连接相关</li><li>PUBLISH/PUBACK 发布相关</li><li>SUBSCRIBE/SUBACK 订阅相关</li><li>UNSUBSCRIBE/UNSUBACK 取消订阅相关</li><li>PINGREQ/PINGRESP 心跳相关</li><li>DISCONNECT 关闭连接</li></ul><h4 id="connect" tabindex="-1"><a class="header-anchor" href="#connect" aria-hidden="true">#</a> CONNECT</h4><figure><img src="http://www.uinio.com/Embedded/MQTT/4.png" alt="MQTT-CONNECT" tabindex="0" loading="lazy"><figcaption>MQTT-CONNECT</figcaption></figure><ul><li><strong>客户端标识符</strong> <code>clientId</code>：用于标识连接到<strong>代理者</strong>的每个<strong>客户端</strong>，该标识符的取值对于<strong>代理者</strong>与<strong>客户端</strong>而言必须唯一；</li><li><strong>清理会话</strong> <code>cleanSession</code>：用于告知<strong>代理者</strong>，当前<strong>客户端</strong>是否需要建立持久会话； <ul><li>当 <code>CleanSession = false</code> 时，<strong>代理者</strong>将存储<strong>客户端</strong>的所有订阅，以及客户端以<strong>服务质量</strong>（QoS）级别 <code>1</code> 或者 <code>2</code> 所订阅的全部遗漏消息；</li><li>当 <code>CleanSession = true</code> 时，<strong>代理者</strong>不但不会为<strong>客户端</strong>保存任何消息，还会清除掉来自于之前持久会话的所有消息；</li></ul></li><li><strong>用户名/密码</strong> <code>username</code>/<code>password</code>：用于对<strong>客户端</strong>进行认证与授权，默认为明文传输，实际应用当中应当进行加密处理；</li><li><strong>临终遗嘱</strong> <code>lastWill*</code>：属于 MQTT <strong>临终遗嘱</strong>（LWT，Last Will and Testament）特性的一部分，当<strong>客户端</strong>非正常断开连接时，用于发送遗嘱消息通知其它的<strong>客户端</strong>；</li><li><strong>保持连接</strong> <code>keepAlive</code>：用于指定<strong>客户端</strong>在连接建立时，与<strong>代理者</strong>通信的时间间隔（以<strong>秒</strong>为单位），即<strong>代理者</strong>与<strong>客户端</strong>在不发送消息的情况下，可以保持连接的最长时间；</li></ul><h4 id="connack" tabindex="-1"><a class="header-anchor" href="#connack" aria-hidden="true">#</a> CONNACK</h4><figure><img src="http://www.uinio.com/Embedded/MQTT/5.png" alt="MQTT-CONNACK" tabindex="0" loading="lazy"><figcaption>MQTT-CONNACK</figcaption></figure><ul><li><p><strong>会话出现标识</strong> <code>sessionPresent</code>：用于告知<strong>客户端</strong>，当前的<strong>代理者</strong>是否已经拥有了一个会话；当<strong>客户端</strong>连接消息的 <code>cleanSession = true</code> 时，由于当前没有可用的会话，所以该项总是为 <code>false</code>；而当<strong>客户端</strong>连接消息的 <code>cleanSession = false</code> 时，此时就会存在两种可能性：</p><ul><li>如果会话消息对于 <code>clientId</code> 可用，并且<strong>代理者</strong>服务已经缓存了这些会话信息，那么 <code>sessionPresent</code> 为 <code>true</code>；</li><li>反之，如果<strong>代理者</strong>没有任何这个 <code>clientId</code> 的会话信息，那么该项就为 <code>false</code>；</li></ul></li><li><p><strong>连接返回码</strong> <code>returnCode</code>：用于通知<strong>客户端</strong>当前连接是否成功，具体取值请参考下面表格：</p><table><thead><tr><th style="text-align:center;">返回代码</th><th>返回码响应</th></tr></thead><tbody><tr><td style="text-align:center;"><code>0</code></td><td>已接受连接；</td></tr><tr><td style="text-align:center;"><code>1</code></td><td>连接被拒绝，不可接受的协议版本；</td></tr><tr><td style="text-align:center;"><code>2</code></td><td>连接被拒绝，标识符被拒绝；</td></tr><tr><td style="text-align:center;"><code>3</code></td><td>连接被拒绝，服务器不可用；</td></tr><tr><td style="text-align:center;"><code>4</code></td><td>连接被拒绝，用户名或密码错误；</td></tr><tr><td style="text-align:center;"><code>5</code></td><td>连接被拒绝，未获得授权；</td></tr></tbody></table></li></ul><h4 id="publish" tabindex="-1"><a class="header-anchor" href="#publish" aria-hidden="true">#</a> PUBLISH</h4><figure><img src="http://www.uinio.com/Embedded/MQTT/6.png" alt="MQTT-PUBLISH" tabindex="0" loading="lazy"><figcaption>MQTT-PUBLISH</figcaption></figure><ul><li><strong>主题名称</strong> <code>topicName</code>：是一段以斜杠<code>/</code>作为分隔符，具有层次结构的简单字符串，例如 <code>home/bedroom/moisture</code>；</li><li><strong>服务质量</strong> <code>qos</code>：服务质量（QoS，Quality of Service）等级有 <code>0</code>、<code>1</code>、<code>2</code> 三个等级，用于确定消息到达接收者（<strong>发布者</strong>、<strong>订阅者</strong>、<strong>代理者</strong>）所需的保障类型；</li><li><strong>保留标记</strong> <code>retainFlag</code>：用于定义<strong>代理者</strong>是否缓存指定<strong>主题</strong>的最后一个正确值，当一个新的<strong>客户端</strong>订阅该<strong>主题</strong>时，就会接收到保留在该<strong>主题</strong>上的最后一条消息；</li><li><strong>负载</strong> <code>payload</code>：指定消息所要传输的实际内容，可以是<code>图像</code>、<code>文本</code>、<code>二进制</code>等数据类型；</li><li><strong>数据包标识符</strong> <code>packetId</code>：在<strong>客户端</strong>与<strong>代理者</strong>进行消息传输时，为每个数据包添加的唯一标识，并且只与大于 <code>0</code> 的 QoS 级别有关，通常由<strong>客户端</strong>或者<strong>代理者</strong>自动进行设置；</li><li><strong>DUP 标志</strong> <code>dupFlag</code>：用于标识这条消息是重复的，由于预期接收者（<strong>客户端</strong>、<strong>代理者</strong>）没有确认原始消息而被重发，该场景仅与 QoS 大于 <code>0</code> 场景有关；</li></ul><h4 id="subscribe" tabindex="-1"><a class="header-anchor" href="#subscribe" aria-hidden="true">#</a> SUBSCRIBE</h4><figure><img src="http://www.uinio.com/Embedded/MQTT/8.png" alt="MQTT-SUBSCRIBE" tabindex="0" loading="lazy"><figcaption>MQTT-SUBSCRIBE</figcaption></figure><ul><li><strong>数据包标识符</strong> <code>packetId</code>：<strong>订阅者</strong>向<strong>代理者</strong>订阅消息时，会自动为每个数据包添加唯一的标识；</li><li><strong>主题/服务质量列表</strong>：一条 <code>SUBSCRIBE</code> 消息可以包含多个订阅，每个订阅由一个 <code>Topic</code> 主题和一个 <code>QoS</code> 级别组成；<code>SUBSCRIBE</code> 消息中的<strong>主题</strong>可以包含<strong>通配符</strong>，以便订阅指定<strong>主题模式</strong>（而非特定的<strong>主题</strong>）；如果当前客户端具有重复的订阅，那么<strong>代理者</strong>将会响应该主题所具有的最高 <code>QoS</code> 级别消息；</li></ul><h4 id="suback" tabindex="-1"><a class="header-anchor" href="#suback" aria-hidden="true">#</a> SUBACK</h4><p>为了确认每条订阅，<strong>代理者</strong>会向<strong>订阅者</strong>发送一条 <code>SUBACK</code> 确认消息，该消息包含有原始订阅消息的<strong>数据包标识符</strong> <code>packetId</code>，以及一个<strong>返回码</strong> <code>returnCode</code> 列表。</p><figure><img src="http://www.uinio.com/Embedded/MQTT/9.png" alt="MQTT-SUBACK" tabindex="0" loading="lazy"><figcaption>MQTT-SUBACK</figcaption></figure><ul><li><strong>数据包标识符</strong> <code>packetId</code>：数据包的唯一标识符，与 <code>SUBSCRIBE</code> 订阅消息当中的 <code>packetId</code> 保持一致；</li><li><strong>返回码</strong> <code>returnCode</code>：<strong>代理者</strong>会为在 <code>SUBSCRIBE</code> 消息当中接收到的每个 <code>topic/qos</code> 响应一个返回码，例如<strong>订阅者</strong>发送的 <code>SUBSCRIBE</code> 消息拥有 <code>5</code> 个订阅，那么<strong>代理者</strong>响应的 <code>SUBACK</code> 退订消息就会包含 <code>5</code> 个返回码，这些返回码用于确认每个<strong>主题</strong>是否都已经被正确订阅，并且展示<strong>代理者</strong>所授予的 QoS 级别；如果<strong>代理者</strong>由于权限或者主题不正确等原因拒绝了本次订阅，则 <code>SUBACK</code> 消息将会包含该主题的失败返回码；</li></ul><table><thead><tr><th style="text-align:center;">返回代码</th><th style="text-align:center;">返回码响应</th></tr></thead><tbody><tr><td style="text-align:center;"><code>0</code></td><td style="text-align:center;"><strong>成功</strong>，最大 QoS 为 <code>0</code>；</td></tr><tr><td style="text-align:center;"><code>1</code></td><td style="text-align:center;"><strong>成功</strong>，最大 QoS 为 <code>1</code>；</td></tr><tr><td style="text-align:center;"><code>2</code></td><td style="text-align:center;"><strong>成功</strong>，最大 QoS 为 <code>2</code>；</td></tr><tr><td style="text-align:center;"><code>128</code></td><td style="text-align:center;"><strong>失败</strong>；</td></tr></tbody></table><h3 id="保持连接-keepalive" tabindex="-1"><a class="header-anchor" href="#保持连接-keepalive" aria-hidden="true">#</a> 保持连接 keepAlive</h3><p>背景</p><p>MQTT构建在TCP之上，TCP能够确保数据包可靠有序，并经过错误检查之后在网络上传输。但有时候通信双方之间的传输会不同步（例如其中一方崩溃或发生传输错误），这种不完整的连接状态在TCP当中被称为<strong>半开连接（Half-open Connection）</strong>，进而造成通信的一方明明已经传输失败，而另一方仍然在尝试发送消息并且等待这些消息被确认。</p><p>方式</p><blockquote><p>CONNECT报文里可设置Keepalive字段，来设置保活心跳包：PINGREQ/PINGRESP的发送时间间隔。</p><p>当长时间无法收到设备的PINGREQ的时候，Broker认为设备已下线</p></blockquote><p>作用</p><ul><li>发现对端死亡或者网络中断</li><li>在长时间无消息交互的情况下，保持连接不被网络设备断开</li></ul><h3 id="消息保留机制" tabindex="-1"><a class="header-anchor" href="#消息保留机制" aria-hidden="true">#</a> 消息保留机制</h3><blockquote><p>发布者只能确保消息安全的传递给代理者，而无法保证消息一定会被订阅者收到。而订阅者可能网路原因导致下线，下线期间的消息需要保证设备下一次上线时送达，MQTT消息保留机制用于解决这个问题。</p></blockquote><h4 id="对于发布者" tabindex="-1"><a class="header-anchor" href="#对于发布者" aria-hidden="true">#</a> 对于发布者</h4><p>发布者在发布主题的时候，将<code>retainFlag</code>设置为<code>true</code>时，代理者会存储该主题下的<code>最后一条保留消息</code>以及相应的QoS级别。</p><p>如果要删除保留消息，则可以向对应的主题发送仅有<code>0 Byte</code>有效载荷的保留消息，代理者会删除之前保留的消息。</p><h4 id="对于订阅者" tabindex="-1"><a class="header-anchor" href="#对于订阅者" aria-hidden="true">#</a> 对于订阅者</h4><p>持久会话会在订阅者与代理者建立连接时，由客户端提供自身的clientId给代理者，用于鉴别每次会话请求。</p><p>代理者通常会持有如下信息：</p><ul><li>该客户端会话之前是否存在；</li><li>该客户端的所有订阅信息；</li><li>在服务质量QoS级别<code>1</code>和<code>2</code>的工作流程当中，客户端尚未确认的消息；（消息已发，但未确认）</li><li>客户端下线时错过的所有新的QoS级别<code>1</code>和<code>2</code>的消息；（新的消息）</li><li>从客户端接收到，但是尚未完全确认的Qos级别<code>2</code>的消息；（消息已发，客户端只确认一次）</li></ul><p>客户端使用一个清理会话<code>cleanSession</code>标志来通知代理者是否持久会话</p><ul><li>当<code>cleanSession=true</code>，表示当前客户端不需要持久化会话，断开连接期间信息会丢失；</li><li>当<code>cleanSession=false</code>，表示当前客户端需要持久化会话，断开连接期间信息会保留；</li></ul><h3 id="临终遗嘱-lastwill" tabindex="-1"><a class="header-anchor" href="#临终遗嘱-lastwill" aria-hidden="true">#</a> 临终遗嘱 lastWill</h3><blockquote><p>当某个客户端未能正常断开与代理者之间的连接，那么就可以采用MQTT的临终遗嘱（LWT，Last Will and Testament）机制来通知其他客户端。</p></blockquote><p>广播时机：</p><ul><li>代理者检测到I/o错误或者网络故障；</li><li>客户端在定义的保持连接周期内通信失败；</li><li>客户端在关闭网络连接之前，没有发送DISCONNECT数据包；</li><li>由于协议发生错误，代理者关闭网络连接；</li></ul><p>最佳实践：</p><blockquote><p>客户端下线，broker向某个topic发布一条消息，通知业务系统设备状态发生更新。</p><ol><li>client1向代理者发送一条带有lastWillMessag参数的CONNECT消息，该消息有效负载<code>payload=&quot;offline&quot;</code>,同时设置临终遗嘱属性为<code>lastWillRetain=true</code>和<code>lastWillTopic=status/client1</code>；</li><li>client1在<code>status/client1</code>主题下发布有效负载<code>payload=&quot;online&quot;</code>以及保留标志<code>retainFlag=true</code>的消息；</li><li>只要client1保持连接，订阅到<code>status/client1</code>主题的客户端就会收到“online”的保留消息；</li><li>如果client1意外断开连接，则代理者将发布有效负载<code>payload=&quot;offline&quot;</code>到<code>status/client1</code>主题，此时其他客户端就知道client1下线。</li></ol></blockquote><h2 id="交互流程" tabindex="-1"><a class="header-anchor" href="#交互流程" aria-hidden="true">#</a> 交互流程</h2><figure><img src="'+g+'" alt="MQTT-交互时序" tabindex="0" loading="lazy"><figcaption>MQTT-交互时序</figcaption></figure><h2 id="报文结构" tabindex="-1"><a class="header-anchor" href="#报文结构" aria-hidden="true">#</a> 报文结构</h2><table><thead><tr><th style="text-align:center;">Fixed header固定报头，2个字节，所有消息类型都包含</th></tr></thead><tbody><tr><td style="text-align:center;">Variable header可变报头，部分消息类型包含</td></tr><tr><td style="text-align:center;">Payload有效载荷，部分消息类型包含</td></tr></tbody></table><h3 id="固定报头" tabindex="-1"><a class="header-anchor" href="#固定报头" aria-hidden="true">#</a> 固定报头</h3><table><tr align="center"><td>Bit</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr align="center"><td>byte1</td><td colspan="4">MQTT控制报文类型</td><td colspan="4">用于指定控制报文类型的控制位</td></tr><tr align="center"><td>byte2</td><td colspan="8">剩余长度</td></tr></table><ul><li><p>MQTT控制报文类型（4~7位置）</p><table><thead><tr><th style="text-align:center;">名字</th><th style="text-align:center;">值</th><th style="text-align:center;">报文流动方向</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">禁止</td><td style="text-align:center;">保留</td></tr><tr><td style="text-align:center;">CONNECT</td><td style="text-align:center;">1</td><td style="text-align:center;">客户端到服务端</td><td style="text-align:center;">客户端请求连接服务端</td></tr><tr><td style="text-align:center;">CONNACK</td><td style="text-align:center;">2</td><td style="text-align:center;">服务端到客户端</td><td style="text-align:center;">连接报文确认</td></tr><tr><td style="text-align:center;">PUBLISH</td><td style="text-align:center;">3</td><td style="text-align:center;">两个方向都允许</td><td style="text-align:center;">发布消息</td></tr><tr><td style="text-align:center;">PUBACK</td><td style="text-align:center;">4</td><td style="text-align:center;">两个方向都允许</td><td style="text-align:center;">QoS 1消息发布收到确认</td></tr><tr><td style="text-align:center;">PUBREC</td><td style="text-align:center;">5</td><td style="text-align:center;">两个方向都允许</td><td style="text-align:center;">发布收到（保证交付第一步）</td></tr><tr><td style="text-align:center;">PUBREL</td><td style="text-align:center;">6</td><td style="text-align:center;">两个方向都允许</td><td style="text-align:center;">发布释放（保证交付第二步）</td></tr><tr><td style="text-align:center;">PUBCOMP</td><td style="text-align:center;">7</td><td style="text-align:center;">两个方向都允许</td><td style="text-align:center;">QoS 2消息发布完成（保证交付第三步）</td></tr><tr><td style="text-align:center;">SUBSCRIBE</td><td style="text-align:center;">8</td><td style="text-align:center;">客户端到服务端</td><td style="text-align:center;">客户端订阅请求</td></tr><tr><td style="text-align:center;">SUBACK</td><td style="text-align:center;">9</td><td style="text-align:center;">服务端到客户端</td><td style="text-align:center;">订阅请求报文确认</td></tr><tr><td style="text-align:center;">UNSUBSCRIBE</td><td style="text-align:center;">10</td><td style="text-align:center;">客户端到服务端</td><td style="text-align:center;">客户端取消订阅请求</td></tr><tr><td style="text-align:center;">UNSUNACK</td><td style="text-align:center;">11</td><td style="text-align:center;">服务端到客户端</td><td style="text-align:center;">取消订阅报文确认</td></tr><tr><td style="text-align:center;">PINGREQ</td><td style="text-align:center;">12</td><td style="text-align:center;">客户端到服务端</td><td style="text-align:center;">心跳请求</td></tr><tr><td style="text-align:center;">PINGRESP</td><td style="text-align:center;">13</td><td style="text-align:center;">服务端到客户端</td><td style="text-align:center;">心跳响应</td></tr><tr><td style="text-align:center;">DISCONNECT</td><td style="text-align:center;">14</td><td style="text-align:center;">客户端到服务端</td><td style="text-align:center;">客户端断开连接</td></tr><tr><td style="text-align:center;">Reserved</td><td style="text-align:center;">15</td><td style="text-align:center;">禁止</td><td style="text-align:center;">保留</td></tr></tbody></table></li><li><p>标志位（0~3位置）</p><table><thead><tr><th style="text-align:center;">控制报文</th><th style="text-align:center;">固定报头标志</th><th style="text-align:center;">Bit3</th><th style="text-align:center;">Bit2</th><th style="text-align:center;">Bit1</th><th style="text-align:center;">Bit0</th></tr></thead><tbody><tr><td style="text-align:center;">CONNECT</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">CONNACK</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">PUBLISH</td><td style="text-align:center;">Used in MQTT 3.1.1</td><td style="text-align:center;">DUP1</td><td style="text-align:center;">QoS2</td><td style="text-align:center;">QoS2</td><td style="text-align:center;">RETAIN3</td></tr><tr><td style="text-align:center;">PUBACK</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">PUBREC</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">PUBREL</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">PUBCOMP</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">SUBSCRIBE</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">SUBACK</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">UNSUBSCRIBE</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">UNSUBACK</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">PINGREQ</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0 v0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">PINGRESP</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">DISCONNECT</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr></tbody></table><p>DUP1 =控制报文的重复分发标志</p><p>QoS2 = PUBLISH 报文的服务质量等级</p><p>RETAIN3 = PUBLISH 报文的保留标志</p></li><li><p>剩余长度</p><p>从第2个字节开始</p><p>包括可变报头和负载的数据，变长度编码方案，每个字节可以编码128个数值和一个延续位，剩余长度字段最大4个。</p></li></ul><h3 id="可变报头" tabindex="-1"><a class="header-anchor" href="#可变报头" aria-hidden="true">#</a> 可变报头</h3><p>某些MQTT控制报文包含一个可变报头部分，它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符字段存在多个类型的报文里。如</p><p>CONNECT报文的可变报头按下列次数包含四个字段：协议名、协议级别、连接标志和保持连接</p><h2 id="mqtt5新特性" tabindex="-1"><a class="header-anchor" href="#mqtt5新特性" aria-hidden="true">#</a> MQTT5新特性</h2><h3 id="自定义mqtt协议头" tabindex="-1"><a class="header-anchor" href="#自定义mqtt协议头" aria-hidden="true">#</a> 自定义MQTT协议头</h3><blockquote><p>MQTT 5可以在协议头部当中添加自定义的键值对，类似HTTP协议。</p></blockquote><h3 id="原因码-reason-codes" tabindex="-1"><a class="header-anchor" href="#原因码-reason-codes" aria-hidden="true">#</a> 原因码 Reason Codes</h3><blockquote><p>原因码用于标识一些预定义的协议错误，通常放置在数据包当中。从而允许客户端与代理者去解释错误条件。原因码有时也被称为消极确认（Negative Acknowledgements）</p></blockquote><h3 id="不支持特性返回码" tabindex="-1"><a class="header-anchor" href="#不支持特性返回码" aria-hidden="true">#</a> 不支持特性返回码</h3><p>背景</p><blockquote><p>许多企业与开源组织并提供了诸多MQTT实现，但是并非所有这些实现都与MQTT规范完全兼容。为此，MQTT5提供了一些返回码说明代理者不支持某个特性，客户端需要解释这些返回码，确保不会使用到这些不支持的特性。</p></blockquote><p>实现</p><blockquote><p>代理者通过<code>CONNACK</code>数据包当中的预定义协议头来标识</p></blockquote><table><thead><tr><th>预定义协议头</th><th>数据类型</th><th>功能描述</th></tr></thead><tbody><tr><td>Retain Available</td><td><code>Boolean</code></td><td>标识<strong>保留消息</strong>是否可用；</td></tr><tr><td>Maximum QoS</td><td><code>Number</code></td><td>允许<strong>客户端</strong>用于发布消息、订阅主题的最大 <strong>QoS</strong> 级别；</td></tr><tr><td>Wildcard available</td><td><code>Boolean</code></td><td><strong>通配符</strong>是否可以用于主题订阅；</td></tr><tr><td>Subscription identifiers available</td><td><code>Boolean</code></td><td><strong>订阅标识符</strong>对于 MQTT 客户端是否可用；</td></tr><tr><td>Shared Subscriptions available</td><td><code>Boolean</code></td><td><strong>共享订阅</strong>对于 MQTT 客户端是否可用；</td></tr><tr><td>Maximum Message Size</td><td><code>Number</code></td><td>MQTT <strong>客户端</strong>能够使用的最大<strong>消息</strong>尺寸；</td></tr><tr><td>Server Keep Alive</td><td><code>Number</code></td><td><strong>代理者</strong>为某个<strong>客户端</strong>所能够支持的<strong>保持连接</strong>时间间隔；</td></tr></tbody></table><h3 id="清理会话" tabindex="-1"><a class="header-anchor" href="#清理会话" aria-hidden="true">#</a> 清理会话</h3><p>背景</p><blockquote><p>MQTT v3.1.1 没有规定持久会话应该什么时候过期，从协议层这个会话应该永久存在，会非常占用服务端的资源。</p><p>清理会话功能由<code>Clean Session</code>拆分为<code>Clean Start</code>和<code>Session Expiry Interval</code></p><ul><li><code>Clean Start</code>字段指定是否需要全新的会话；</li><li><code>Session Expiiry Interval</code>字段指定会话过期时间；</li></ul></blockquote><h3 id="auth数据包" tabindex="-1"><a class="header-anchor" href="#auth数据包" aria-hidden="true">#</a> AUTH数据包</h3><blockquote><p>MQTT5引入了崭新的AUTH包，主要应用于实现一些特定的身份验证机制。</p></blockquote><h3 id="双向断开disconnect" tabindex="-1"><a class="header-anchor" href="#双向断开disconnect" aria-hidden="true">#</a> 双向断开DISCONNECT</h3><blockquote><p>MQTT3.1.1客户端会在关闭TCP之前，发送DISCONNECT数据包来通知代理者服务正常断开连接。</p><p>MQTT5允许代理者向客户端发送DISCONNECT数据包</p></blockquote><h3 id="qos级别1与2消息不再重试" tabindex="-1"><a class="header-anchor" href="#qos级别1与2消息不再重试" aria-hidden="true">#</a> QoS级别1与2消息不再重试</h3><blockquote><p>MQTT3.1.1对应QoS级别为1和2条件下，如果TCP连接中断，会发起多次TCP连接保证消息被正确的传递。但对于超出负载能力的客户端可能会因此变得更加超载</p></blockquote><p>例如：</p><ul><li>客户端从代理者接收到一条消息，需要耗时11秒处理，并且在处理之后确认数据包</li><li>代理者会在10秒之后重新传输消息，会浪费带宽并加重客户端的负担。</li></ul><blockquote><p>MQTT5不允许代理者和客户端在正常的TCP连接上重新传递消息，如果遇到TCP连接关闭，则代理者与客户端必须重新发送未经确认的数据包。即：不重新发送消息，而是发送确认包。</p></blockquote><h2 id="安全" tabindex="-1"><a class="header-anchor" href="#安全" aria-hidden="true">#</a> 安全</h2><h3 id="传输层认证" tabindex="-1"><a class="header-anchor" href="#传输层认证" aria-hidden="true">#</a> 传输层认证</h3><blockquote><p>传输层支持TLS认证，并加密通讯</p><p>如果客户端不支持TLS，可以对消息体进行加密</p></blockquote><h3 id="应用层认证" tabindex="-1"><a class="header-anchor" href="#应用层认证" aria-hidden="true">#</a> 应用层认证</h3><blockquote><p>不加密通讯，支持：</p><ul><li>client id</li><li>username/password</li></ul></blockquote><h3 id="broker管理" tabindex="-1"><a class="header-anchor" href="#broker管理" aria-hidden="true">#</a> Broker管理</h3><blockquote><p>对topic增加读写管理权限，可以限制指定用户对指定Topic的数据读写</p></blockquote><h2 id="开源mqtt-broker" tabindex="-1"><a class="header-anchor" href="#开源mqtt-broker" aria-hidden="true">#</a> 开源MQTT broker</h2>',85),v={href:"https://github.com/mqtt/mqtt.org/wiki/servers",target:"_blank",rel:"noopener noreferrer"},_=t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"center"}}),t("th",{style:{"text-align":"center"}},"Eclipse Mosquitto"),t("th",{style:{"text-align":"center"}},"EMQX"),t("th",{style:{"text-align":"center"}},"Mosca"),t("th",{style:{"text-align":"center"}},"VerneMQ"),t("th",{style:{"text-align":"center"}},"ejabberd"),t("th",{style:{"text-align":"center"}},"emitter")])],-1),q=t("td",{style:{"text-align":"center"}},"地址",-1),M={style:{"text-align":"center"}},B={href:"https://github.com/eclipse/mosquitto",target:"_blank",rel:"noopener noreferrer"},N={style:{"text-align":"center"}},P={href:"https://github.com/emqx/emqx",target:"_blank",rel:"noopener noreferrer"},I={style:{"text-align":"center"}},E={href:"https://github.com/moscajs/mosca",target:"_blank",rel:"noopener noreferrer"},U={style:{"text-align":"center"}},R={href:"https://github.com/vernemq/vernemq",target:"_blank",rel:"noopener noreferrer"},A={style:{"text-align":"center"}},L={href:"https://github.com/processone/ejabberd",target:"_blank",rel:"noopener noreferrer"},w={style:{"text-align":"center"}},O={href:"https://github.com/emitter-io/emitter",target:"_blank",rel:"noopener noreferrer"},K=t("tr",null,[t("td",{style:{"text-align":"center"}},"开源协议"),t("td",{style:{"text-align":"center"}},"Eclipse Public License 2.0"),t("td",{style:{"text-align":"center"}},"APL-2.0"),t("td",{style:{"text-align":"center"}},"无"),t("td",{style:{"text-align":"center"}},"APL-2.0"),t("td",{style:{"text-align":"center"}},"GPL-2.0"),t("td",{style:{"text-align":"center"}},"AGPL-3.0")],-1),D=t("tr",null,[t("td",{style:{"text-align":"center"}},"Star"),t("td",{style:{"text-align":"center"}},"6.2k"),t("td",{style:{"text-align":"center"}},"9.6k"),t("td",{style:{"text-align":"center"}},"3.1k"),t("td",{style:{"text-align":"center"}},"2.7k"),t("td",{style:{"text-align":"center"}},"5.2k"),t("td",{style:{"text-align":"center"}},"3.3k")],-1),H=t("tr",null,[t("td",{style:{"text-align":"center"}},"更新频率"),t("td",{style:{"text-align":"center"}},"几个月前"),t("td",{style:{"text-align":"center"}},"经常"),t("td",{style:{"text-align":"center"}},"2020年1月不再更新"),t("td",{style:{"text-align":"center"}},"经常"),t("td",{style:{"text-align":"center"}},"经常"),t("td",{style:{"text-align":"center"}},"几个月前")],-1),G=t("tr",null,[t("td",{style:{"text-align":"center"}},"开发语言"),t("td",{style:{"text-align":"center"}},"C"),t("td",{style:{"text-align":"center"}},"Erlang"),t("td",{style:{"text-align":"center"}},"nodejs"),t("td",{style:{"text-align":"center"}},"Erlang"),t("td",{style:{"text-align":"center"}},"Erlang"),t("td",{style:{"text-align":"center"}},"go")],-1),W=t("tr",null,[t("td",{style:{"text-align":"center"}},"协议支持"),t("td",{style:{"text-align":"center"}},"MQTT3.1、MQTT3.1.1、MQTT5"),t("td",{style:{"text-align":"center"}},"MQTT3.1、MQTT3.1.1、MQTT5"),t("td",{style:{"text-align":"center"}},"MQTT3.1、MQTT3.1.1"),t("td",{style:{"text-align":"center"}},"MQTT3.1、MQTT3.1.1、MQTT5"),t("td",{style:{"text-align":"center"}},"MQTT3.1、MQTT3.1.1、MQTT5"),t("td",{style:{"text-align":"center"}})],-1),z=t("tr",null,[t("td",{style:{"text-align":"center"}},"集群能力"),t("td",{style:{"text-align":"center"}},"通过桥接支持集群"),t("td",{style:{"text-align":"center"}},"支持"),t("td",{style:{"text-align":"center"}},"支持"),t("td",{style:{"text-align":"center"}},"支持"),t("td",{style:{"text-align":"center"}},"支持"),t("td",{style:{"text-align":"center"}})],-1),V=t("tr",null,[t("td",{style:{"text-align":"center"}},"扩展能力"),t("td",{style:{"text-align":"center"}},"持久化到磁盘"),t("td",{style:{"text-align":"center"}},"支持关系数据库、NoSQL、以及常见的消息队列如：kafka、RabbitMQ、Pulsar"),t("td",{style:{"text-align":"center"}}),t("td",{style:{"text-align":"center"}},"支持离线消息存储（LevelDB）,身份验证（MongoDB、Redis、PostgreSQL、CockroachDB、Memcached）、支持Lua脚本"),t("td",{style:{"text-align":"center"}},"支持MySQL、PostgreSQL持久化数据，redis会话，lua脚本"),t("td",{style:{"text-align":"center"}},"支持内存、SSD")],-1);function F(j,$){const n=o("ExternalLinkIcon");return i(),s("div",null,[u,x,t("ul",null,[y,p,t("li",null,[e("2014年在 "),b,e(" 标准化组织的推动下于公布了 "),t("a",m,[T,d(n)]),e(" 版本规范。")]),t("li",null,[e("2019年3月发布了最新的 "),t("a",S,[f,d(n)]),e(" 版本规范。")])]),Q,t("p",null,[t("a",k,[e("http://www.steves-internet-guide.com/mqtt-publish-subscribe/"),d(n)])]),C,t("p",null,[t("a",v,[e("https://github.com/mqtt/mqtt.org/wiki/servers"),d(n)])]),t("table",null,[_,t("tbody",null,[t("tr",null,[q,t("td",M,[t("a",B,[e("https://github.com/eclipse/mosquitto"),d(n)])]),t("td",N,[t("a",P,[e("https://github.com/emqx/emqx"),d(n)])]),t("td",I,[t("a",E,[e("https://github.com/moscajs/mosca"),d(n)])]),t("td",U,[t("a",R,[e("https://github.com/vernemq/vernemq"),d(n)])]),t("td",A,[t("a",L,[e("https://github.com/processone/ejabberd"),d(n)])]),t("td",w,[t("a",O,[e("https://github.com/emitter-io/emitter"),d(n)])])]),K,D,H,G,W,z,V])])])}const J=l(h,[["render",F],["__file","MQTT.html.vue"]]);export{J as default};
