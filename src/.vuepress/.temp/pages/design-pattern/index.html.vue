<template><div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>面向对象是<strong>武器</strong></p>
<p>设计模式是<strong>招式</strong></p>
<p>设计原则是<strong>心法</strong></p>
<p>以心法为基础，以武器运用招式应对复杂的编程问题</p>
</div>
<!-- more -->
<h2 id="什么是设计模式" tabindex="-1"><a class="header-anchor" href="#什么是设计模式" aria-hidden="true">#</a> 什么是设计模式</h2>
<p>设计模式最早来源于建筑领域</p>
<blockquote>
<p>克里斯托弗.亚历山大在作品《建筑的永恒之道》中这样说：&quot;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。&quot;</p>
</blockquote>
<p>之后四人组（Gang of Four，简称GoF）将模式的概念应用在软件开发设计中，定义如下：</p>
<blockquote>
<p>它是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。</p>
</blockquote>
<p>简单来说，就是<strong>解决特定问题的一系列解决方案</strong>，是前辈们的代码设计经验的总结。</p>
<h3 id="具有哪些优点" tabindex="-1"><a class="header-anchor" href="#具有哪些优点" aria-hidden="true">#</a> 具有哪些优点</h3>
<ul>
<li>优化软件设计：设计模式通常由经验丰富的开发者提供实现，可以提高软件的可重用性、可扩展性和可维护性。</li>
<li>提高软件质量：设计模式通常会规范代码编写，有助于减少代码中的错误和问题。</li>
<li>提高团队协作效率：设计模式具有通用性和标准化，从而使团队成员更容易合作编写代码，提高协作效果。</li>
<li>提高系统性能：设计模式可以优化代码实现，提高系统性能。</li>
</ul>
<h3 id="四要素" tabindex="-1"><a class="header-anchor" href="#四要素" aria-hidden="true">#</a> 四要素</h3>
<ul>
<li><strong>问题</strong>：问题或称为上下文、场景，指在软件开发中需要解决的某个问题或需求。设计模式通常解决针对特定上下文或场景中出现的问题。</li>
<li><strong>解决方案</strong>：解决方案或称为模型、模式，是指用于解决上述问题的通用方法或最佳实践。设计模式描述了解决某问题的方法或模板，并提供了这些方法的实现细节，使得类似问题可以被解决且易于复用。</li>
<li><strong>效果</strong>：效果或称为结果、贡献，是指使用该模式带来的好处和优点。设计模式提供了可重用、灵活的解决方案，增加可维护性、可扩展性和可重用性。</li>
<li><strong>元素</strong>：元素或称为参与者、角色、类和对象，组成了设计模式的各个部分。这些元素可以是类、对象、接口、方法等等。元素描述了在特定上下文或场景中参与模式实现的各种组件。</li>
</ul>
<h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2>
<figure><img src="@source/design-pattern/images/design-pattern.png" alt="分类" tabindex="0" loading="lazy"><figcaption>分类</figcaption></figure>
<h3 id="创建型设计模式" tabindex="-1"><a class="header-anchor" href="#创建型设计模式" aria-hidden="true">#</a> 创建型设计模式</h3>
<blockquote>
<p>创建型设计模式是一种常用的设计模式，常用于对象的创建和初始化，这些模式描述了创建对象的不同方式，以及处理对象创建的方案。</p>
</blockquote>
<h4 id="相同点" tabindex="-1"><a class="header-anchor" href="#相同点" aria-hidden="true">#</a> 相同点</h4>
<ul>
<li>都可以抽象和封装对象的创建过程；</li>
<li>在代码中高度模块化，提高了代码的重用性和可维护性；</li>
<li>通过减轻了耦合关系，可以降低系统的复杂度；</li>
<li>为对象创建提供了规范化的方式，使得对象的创建更加简单易懂。</li>
</ul>
<h4 id="不同点" tabindex="-1"><a class="header-anchor" href="#不同点" aria-hidden="true">#</a> 不同点</h4>
<ul>
<li>单例模式旨在确保一个类只有一个实例，通过提供全局唯一的实例，方便对实例的管理和调用；</li>
<li>工厂模式旨在将对象的创建和对象本身分离开来，确保对象的创建过程不会影响代码的其他部分；</li>
<li>抽象工厂模式在工厂方法模式的基础上，为不同类型的工厂方法定义了一个抽象的父类，使工厂拥有高度的可扩展性；</li>
<li>建造者模式旨在将对象的创建过程拆分成多个部分，通过组合的方式实现最终对象的创建；</li>
<li>原型模式旨在通过克隆已有对象的方式来创建新的对象，以避免重复的对象创建过程。</li>
</ul>
<h3 id="结构型设计模式" tabindex="-1"><a class="header-anchor" href="#结构型设计模式" aria-hidden="true">#</a> 结构型设计模式</h3>
<blockquote>
<p>结构型设计模式是一组用于组织类和对象之间关系的设计模式，它们通常用于提高代码的可维护性、可扩展性和可重用性。结构型设计模式分为<code v-pre>类结构型模式</code>和<code v-pre>对象结构型模式</code>。</p>
</blockquote>
<p>其中：</p>
<ul>
<li><code v-pre>类结构型模式</code>关注类之间的组合，例如装饰器模式、适配器模式、代理模式等；而<code v-pre>对象结构型模式</code>关注对象之间的组合，例如组合模式、享元模式等。</li>
<li><code v-pre>类结构型模式</code>更侧重于对象之间的静态关系，即在编译时期已经确定相关类之间的关系，而<code v-pre>对象结构型模式</code>更侧重于对象之间的动态关系，即在运行时期可以动态添加或移除对象。</li>
<li><code v-pre>类结构型模式</code>的使用场景更为广泛，适用于不同的问题领域；而<code v-pre>对象结构型模式</code>更加专注于一些具体的问题场景。</li>
</ul>
<h4 id="相同点-1" tabindex="-1"><a class="header-anchor" href="#相同点-1" aria-hidden="true">#</a> 相同点</h4>
<ul>
<li>都可以用于组织和组合类之间的关系；</li>
<li>在代码中提供了高度模块化的方式，便于代码的重用和维护；</li>
<li>通过组合、代理、继承等方式，可以更加灵活地设计类的层次结构；</li>
<li>可以降低系统的复杂度，提高代码的可读性和可维护性。</li>
</ul>
<h4 id="不同点-1" tabindex="-1"><a class="header-anchor" href="#不同点-1" aria-hidden="true">#</a> 不同点</h4>
<ul>
<li>代理模式旨在控制对对象的访问，为使用者提供简化的接口，同时也可以提升对象的访问效率；</li>
<li>适配器模式旨在将不同对象之间的接口协调起来，使它们能够协同工作；</li>
<li>桥接模式旨在将类的抽象和实现分离出来，使得两者可以独立地变化；</li>
<li>装饰器模式旨在动态地添加类的额外行为，而无需修改类的接口和实现；</li>
<li>外观模式旨在将一组紧密相关的类中的复杂逻辑抽象出来，提供一个简单的接口给使用者；</li>
<li>享元模式旨在共享多个具有相同状态的对象，以减少内存的占用。</li>
</ul>
<h3 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式" aria-hidden="true">#</a> 行为型设计模式</h3>
<blockquote>
<p>行为型设计模式是一类用于处理对象之间交互、职责划分以及算法封装等问题的设计模式，这类设计模式关注的是对象之间的通信以及行为的分配，可以帮助解决对象之间职责不够清晰、相互依赖、难以复用等问题。</p>
</blockquote>
<h4 id="相同点-2" tabindex="-1"><a class="header-anchor" href="#相同点-2" aria-hidden="true">#</a> 相同点</h4>
<ul>
<li>都是用于描述和组织对象的行为和交互方式；</li>
<li>通过将复杂的交互拆分成多个独立的部分，提高代码的重用性和可维护性；</li>
<li>用于降低对象之间的耦合度，提高代码的可扩展性和灵活性；</li>
<li>通过定义抽象接口和规范方法调用方式，提高代码的规范性和可读性。</li>
</ul>
<h4 id="不同点-2" tabindex="-1"><a class="header-anchor" href="#不同点-2" aria-hidden="true">#</a> 不同点</h4>
<ul>
<li>观察者模式旨在实现对象之间的松耦合关系，当一个对象状态发生改变时，它会通知它所观察到的所有对象；</li>
<li>模板方法模式旨在将通用的算法框架定义为一个抽象函数，然后由子类实现具体算法的不同部分；</li>
<li>策略模式是定义一族算法、封装每个算法，并使这些算法可以互换，从而让算法的变化独立于客户端；</li>
<li>命令模式旨在将请求封装成对象，以便于参数化和传递，同时支持请求排队、记录日志、撤销等操作；</li>
<li>责任链模式旨在将请求的处理方式连成一个链，每个对象都尝试处理该请求，直到其中一个对象处理成功为止；</li>
<li>迭代器模式是在不暴露集合内部结构的情况下，提供一种访问元素的方式；</li>
<li>访问者模式则是定义了一组对数据结构中的元素进行操作的方法，通过这些方法可以实现对数据结构的统一处理。</li>
</ul>
</div></template>


