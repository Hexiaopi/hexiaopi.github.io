# 数组

> 一个由固定长度的特定类型组成的序列。特定类型可以是：字符串、结构体、函数、接口、通道等。

## 定义

```go
var a [3]int								//长度为3的int类型数组，元素为[0,0,0]
var b = [...]int{1,2,3}			//长度为3的int类型数组，元素为[1,2,3]
var c = [...]int{1:2,2:3}		//长度为3的int类型数组，元素为[0,2,3]
var d = [...]int{0,2,2:3,4}	//长度为4的int类型数组，元素为[0,2,3,4]
```

👣

​	定义数组可以指定长度，例如第1种定义；也可以根据初始化元素的数目自动计算，例如第2、3、4种定义。

​	初始化数组元素可以按顺序指定，例如第2种定义；也可以根据索引指定元素，例如第3、4种定义。

## 操作

### len()

> len()函数可以用于计算数组的长度。

### cap()

> cap()函数可以用于计算数组的容量。

👣

​	len()和cap()对于数组来说，结果始终一致。

## 遍历

```go
for i:=range a{
	fmt.Printf("a[%d]: %d\n",i,a[i])
}

for i,v:=range a{
	fmt.Printf("a[%d]: %d\n",i,v)
}

for i:=0;i<len(a);i++{
  fmt.Printf("a[%d]: %d\n",i,a[i])
}
```

👣

- `for range`方式迭代可以保证不会出现数组越界的情况。
- 数组的定义包含长度，因此长度不同的数组，即便类型一致，整个数组仍不是同一类型。
- 长度为`0`的数组（空数组）在内存中并不占用空间。

------

# 切片

> 切片（slice）简称动态数组，既然是动态，切片的长度可以动态伸缩。

切片的结构定义，即`reflect.SliceHeader`:

```go
type SliceHeader struct{
	Data uintptr
	Len int
	Cap int
}
```

切片的定义包含三个字段：

- 第一个字段是切片指向的底层数组；
- 第二个字段表示切片的长度
- 第三个字段表示切片的容量

## 定义

```go
var (
	a []int							// nil切片，表示不存在的切片
	b = []int{}					// 空切片，不等于nil，表示空的集合
	c = []int{1,2,3}		// 指向包含三个元素的数组：[1，2，3]。len和cap为3
	d = c[:2]						// 与c指向同一个数组，但是len为2，cap为3
	e = c[0:2:cap(c)]		// 与c指向同一个数组，但是len为2，cap为cap(c)的大小，即3
	f = c[:0]						// 与c指向同一个数组，但是len为0，cap为3
	g = make([]int,3)		// 指向新的数组，包含三个元素：[0,0,0]。len和cap为3
	h = make([]int,2,3)	// 指向新的数组，包含三个元素：[0,0,0]。len为2，cap为3
	i = make([]int,0,3)	// 指向新的数组，包含三个元素：[0,0,0]。len为0，cap为3
)
```

👣

​	切片的容量必须大于等于切片的长度。

## 操作

和数组类似，可以使用`len()`和`cap()`函数获取切片的长度和容量。此外可以使用`append()`对切片追加元素，但`append()`远不止这个功能。

### 1. 添加切片元素

#### 在切片尾部追加元素：

```go
var a []int										//为nil
a = append(a,1)								//追加一个元素，len和cap都为1
a = append(a,2,3,4)						//追加三个元素，len和cap都为4
a = append(a []int{5,6,7}...)	//追加一个切片，len为7，cap为8
```

在追加元素过程中，如果容量不足，`append()`操作会导致重新分配内存，例如第二行对为nil的切片申请空间，但申请的内存并不一定为所需的空间，如第四行。

#### 在切片头部追加元素：

```go
var a = []int{1,2,3}							//len和cap都为3
a = append([]int{0},a...)					//在开头添加一个元素，len和cap都为4
a = append([]int{-3,-2,-1},a...)	//在开头添加一个切片，len为7，cap为8
```

在切片开头追加元素会导致内存的重新分配，已有的元素会复制一份。因此从切片的头部追加元素的性能很差，也很少使用到。

#### 在切片中间追加元素：

```go
var a = []int{1,2,7}
a = append(a[:2],append([]int{3},a[2:]...)...) 			//追加一个元素，现在包含元素[1,2,3,7]
a = append(a[:3],append([]int{4,5,6},a[3:]...)...)	//追加一个切片，现在包含元素[1,2,3,4,5,6,7]
```

同样，在切片中间追加元素，会创建许多临时切片，性能比较差。可以使用`copy()`函数完成类似的功能：

```go
var a = []int{1,2,4}		// [1,2,4],cap=3
a = append(a,0)					// [1,2,4,0],cap=6
copy(a[3:],a[2:])				// [1,2,0,4],cap=6
a[2] = 3								// [1,2,3,4],cap=6
```

`copy(target,source)`函数，将source的内容复制到target，相比较append，节省了临时切片的创建。

### 2. 删除切片元素

#### 在切片头部删除元素

```go
var a = []int{1,2,3}					// [1,2,3],len=3,cap=3
a = append([]int{},a[1:]...)  // [2,3],len=2,cap=2
```

这里的len和cap都为2，是因为重新分配了内存空间

#### 在切片中部删除元素

```go
var a = []int{1,2,3,4}			// [1,2,3,4],len=4,cap=4
a = append(a[:1],a[2:]...)	// [1,3,4],len=3,cap=4
```

#### 在切片尾部删除元素

```go
var a = []int{1,2,3}		// [1,2,3],len=3,cap=3
a = a[:2]								// [2,3],len=2,cap=3
```

删除尾部一个元素：`a = a[:len(a)-1]`

删除尾部N个元素：`a = a[:len(a)-N]`