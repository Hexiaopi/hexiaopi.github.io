## 1. 变量

> 程序运行过程中，数据常常分配在内存中，我们在编码阶段用一个易于阅读的名字来定义这块内存，这块内存上存储的数据其值可以经常改变，我们就称为变量(variable)
>
> 变量的类型决定了变量在内存的长度和存储格式

### 1.1 定义

```go
var <variable_name> [variable_type]
```

定义一个变量：

```
var x int			//自动初始化int的零值即0
var y = false //编译器自动推断为bool类型，并赋值为false
```

:eyes:

- 编译器确保变量被初始化为`零值`，避免出现不可预测行为
- 定义的变量如果未使用，会编译不通过

定义多个变量：

```go
//不同类型变量
var (
  i int 
  s string
)
//相同类型变量
var x,y int 
```

定义短变量：

```go
count := 10 //编译器自动推断为int类型
x,y := 0,1	//多个变量同时定义
```

:eyes: 

- 必须给变量相同数量的值，由编译器推断类型

- 短变量声明只可存在函数中，不可全局声明

  ```go
  package main
  
  import "fmt"
  
  x:=0		//编译失败
  
  func main(){
  	fmt.Println(x)
  }
  ```

- 由于使用了`:=`，因此至少有一个`新声明的变量`出现在左值，否则编译失败

  ```go
  var x,y int
  x,y:=0,1 //编译失败
  x,z:=0,1 //z是新声明的变量
  ```

- 存在变量地址变化问题，须小心使用

  ```go
  package main
  
  import "fmt"
  
  var x = 100
  
  func main() {
  	fmt.Println(&x, x)
  	x = 101
  	fmt.Println(&x, x)
  	x := 102
  	fmt.Println(&x, x)
  	x, y := 200, 2
  	fmt.Println(&x, x, y)
  	{
  		x, z := 300, 3
  		fmt.Println(&x, x, z)
  	}
  	fmt.Println(&x, x)
  }
  
  
  //输出
  0x1149268 100				//x初始地址和值
  0x1149268 101				//只是修改了值
  0xc0000140a0 102		//x被重新定义，x的地址已经发生变化
  0xc0000140a0 200 2	//由于y是新声明的变量，x没有被重新定义，x的地址没有发生变化
  0xc0000140a8 300 3	//新的作用域，x为新定义的变量，作用范围在该作用域内
  0xc0000140a0 200		//离开作用域，x为上文的变量
  ```

定义匿名变量：

> 匿名变量是以下划线`_`声明的，通常用于多值返回时忽略某个值

```
result,_ := json.Marshal(s) //忽略err
```

### 1.2 变量的类型

变量的类型划分方式比较多，这里按照变量的**数据类型**进行划分：值类型、复合类型、引用类型

值类型

> 值类型即基本的数据类型，包括布尔类型（bool）、整型（int）、浮点型（float）、字节型（byte）、复数型（complex）、字符串型（string）和错误类型（error）。
>
> 值类型的变量在传递过程中，编译器对该变量的值进行一次拷贝。

复合类型

> 复合类型即比较复杂的数据类型，包括数组（array）、结构体（struct）。数组里存放的是一组相同类型的数据，结构体里存放的是不同类型的数据。
>
> 与值类型一致，复合类型变量在传递过程也是进行值拷贝。

引用类型

> 引用类型即指针类型，包括指针（pointer）、切片（silence）、字典（map）、通道（channel）、接口（interface）和函数（function）。

:eyes: 

值类型和引用类型的区别在于，在函数参数传递过程中

- 值类型的变量的值复制一份传递
- 引用类型的变量是把自己的内存地址传递

### 1.3 变量的零值

Go语言中，当一个变量被定义为某一种数据类型后，Go语言回自动初始化其值为零值（Zero Value），零值并不等于空值，而是对应数据类型的默认值。

- 整型默认值为：0
- 浮点型默认值为：0.0
- 布尔类型的默认值是：false
- 字符串类型的默认值为：""
- `function`、`interface`、`map`、`slice`、`channel`等类型为nil，表示没有分配内存地址
- `struct`和`array`则是分配了内存，其子元素对应上述的零值

### 1.4 变量的作用域

变量的作用（使用）范围称为变量的作用域，通常来说，一段程序代码中所用到的变量并不总是有效或可用的，而限定这个变量的可用范围即作用域，根据作用域可将变量分为两种：全局变量和局部作变量。

作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了命名冲突。

全局变量

>全局变量（Global Variables）是在函数外部定义的变量，它的作用范围涵盖了整个包。

局部变量

> 局部变量（Local Variables）是在函数内部定于的变量，它的作用范围仅限域函数内部。

## 2 常量

> 常量（constant），顾名思义，程序运行期间，其值不能改变的量。

### 2.1 定义

```
const <constant_name> [constant_type] = <赋值表达式>
```

定义一个常量：

```go
const PI float32 = 3.1415926

const str = "Go" //编译器自动推断类型为string类型
```

定义多个常量：

```go
const a, b, c = 1, "Go", 'c' //自动推断a是整型、b是字符串类型、c是字节型
```

定义常量组：

```go
const (
	COLON = ":"
	EMPTY = ""
)
//Go的标准库有很多这种写法，例如http/status.go声明了许多http状态码。
```

:eyes:

- 如果不指定类型和初始化值，则默认表示使用上行的赋值表达式

  ```go
  const (
  	x int = 1
  	y						//y为1
  	a = "a"
  	b						//b为"a"
  	c = ""
  	d						//d为""
  )
  ```

### 2.2 初始化

规则：

- 常量值必须是确定的，不能使用程序运行期间不确定的值

  ```go
  const (
    x = runtime.NumCPU()	//编译不通过，因为runtime.NumCPU()是在程序运行期间获取到的机器CPU个数
    y = len("hello world") //编译通过，内置函数len等可以使用
  )
  ```

- 常量的值在编译过程已确定，作为指令数据使用，没有内存分配

  ```go
  package main
  
  import (
  	"fmt"
  )
  
  const x = 100
  
  func main() {
  	fmt.Println(&x,x)		//编译不通过，获取不到地址
  }
  ```

### 2.3 枚举

> 枚举，一组常量值，通常用于限定值的范围。

例如：

```go
const (
	Sunday    = iota //0
	Monday    = iota //1
	Tuesday   = iota //2
	Wednesday = iota //3
	Thursday  = iota //4
	Friday    = iota //5
	Saturday  = iota //6
)
```

:eyes:**规则说明：**

- 常量组每定义一个常量**iota**就会自动递增1
- 每遇到一个const关键字，iota就会重置为0
- 如果按行递增（如上例所示），可省略后续的iota关键字

```go
package main

import "fmt"

const (
	a = 'A'
	b
	c = iota
	d
)

const (
	e = 'E'
	f = iota
)

func main() {
	fmt.Println(a, b, c, d, e, f)
}

//输出
//65 65 2 3 69 1
```

## 3. 命名规则

> Go语言中用来对符号常量、变量、函数、数组、切片、通道等数据对象命名的有效字符序列统称为标识符（Identifier）即数据对象的名字。

Go语言的命名规则：

- 变量名必须以字母或下划线开始；
- 必须使用英文字母、数字、下划线组成，不能出现空格或制表符；
- 不能使用Go语言内置关键字和保留字，如：go、func、break、defer等；
- 大小写敏感，比如`x`和`X`是两个不一样的标识符；

